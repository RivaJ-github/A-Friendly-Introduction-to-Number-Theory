\chapter{整除性和最大公约数}
\begin{theorem}[欧几里得算法]
要计算两个整数$a$和$b$的最大公约数，先令$r_{-1}=a$且$r_0=b$，然后计算相继的商和余数
\[r_{i-1}=q_{i+1}r_i+r_{i+1}\quad (i=0,1,2,\cdots)\]
直到某余数$r_{n+1}=0$。最后的非零余数$r_n$就是$a$和$b$的最大公约数
\end{theorem}
%
\exercise 运行code/exe\_5\_1.py
\[\gcd(12345, 67890)= 15\quad
\gcd(54321, 9876)= 3\]
%
\exercise 
\begin{lstlisting}
'''
最大公约数(欧几里得算法)
'''
def gcd(a, b):
    if (b == 0):
        return a
    return gcd(b, a%b)
\end{lstlisting}
%
\exercise 已知$r_i$是严格递减的，即$r_i > r_{i+1}$。
假如$r_{i+1} \le \frac{1}{2}r_i$，则显然$r_{i+2} < r_{i+1}\le \frac{1}{2}r_i$。
因此我们假定$r_{i+1}> \frac{1}{2}r_i$，此时$r_i$除以$r_{i+1}$的商是1，余数是$r_i - r_{i+1}$。即欧几里得算法中下一次迭代的$r_{i+2}=r_i - r_{i+1}$。因为$r_{i+1}> \frac{1}{2}r_i$，所以$r_{i+2} < \frac{1}{2}r_i$。\par
现在已经证明欧几里得算法每两步将余数至少减小一半。因此$2N$步后，至少将余数减小为$1/2^N$。已知$r_1 < b$，因此$2N$步后，余数将小于$n/2^N$。一旦某一步余数小于1，这个余数必为0。因此，只要$N>\log_2(b)$，将得到余数0，这意味着欧几里得算法决不会超过$2\log_2(b)$步。观察下式：
\[2\log_2(b)=2\frac{\log_{10}(b)}{\log_{10}(2)}\approx 6.64385619\log_{10}(b)\]
其中$\log_{10}(b)$大于$b$的位数。\par
一个有趣的扩展练习是尝试获得对欧几里得算法的步数的更好的估计。有可能证明欧几里得算法会在$1.45\log_2(N)+1.68$步内终止。所以，如果$N$不是太小，比如$N>1000$，则欧几里得算法的步数将小于$N$的位数的5倍。
%
\exercise a）使用
$\mathrm{LCM}(8, 12) = 24$\quad
$\mathrm{LCM}(20, 30) = 60$\quad
$\mathrm{LCM}(51, 68) = 204$\quad
$\mathrm{LCM}(23, 18) = 414$\par
b）$\mathrm{LCM}(m, n) = mn / \gcd(m, n)$\par
c）\proof 首先，记$L = m n / \gcd(m, n)$，$g=\gcd(m,n)$，则$L=(m/g)n = m(n/9)$，其中$n/g$和$m/g$都是整数，因此$L$确实是$m$，$n$的一个公倍数。\par
假设$K$是$m$，$n$的另一个公倍数，这意味着$K=am$且$K=bn$。我们知道$g$可以表示为$g=um+vn$，因此
\begin{align*}
    K=&(K/g)g=(K/g)(um+vn)=(uKm)/g+(vKn)/g \\
    =&(uanm)/g+(vbmn)/g=uaL+vbL
\end{align*}
$K=L(ua+vb)$，于是不仅$K\ge L$，$K$还是$L$的倍数。\par
d）$LCM(301337, 307829) = 171460753$\par
e）记$m=18M$，$n=18N$。则$\gcd(M, N)=1$。根据b）得到的公式：
\[720=\mathrm{LCM}(m,n)=mn/gcd(m,n)=18MN\]
因此$MN=720/18=40=2^3\cdot 5$，为保证$(M,N)$互素，只有以下四种可能性$(40,1)$，$(8,5)$，$(5,8)$，$(1,40)$。对应$(m,n)$的四种可能值：$(720,18)$，$(144,90)$，$(90,144)$，$(18,720)$
%
\exercise 使用code/exe5\_5.py计算任意值的终止处和算法长度。\par
a）(\romannumeral1)$n=21$时，终止于1，算法长度为8；
(\romannumeral2)$n=13$时，终止于1，算法长度为10；
(\romannumeral3)$n=31$时，终止于1，算法长度为107；\par
b）我们推测算法总是终止于1，虽然这个结论还未被证明。\par
c）\proof 对于$n=8k+4$，算法运行如下：
\[8k+4\rightarrow4k+2\rightarrow2k+1\rightarrow6k+4\]
对于$n=8k+5$，算法运行如下：
\[8k+5\rightarrow24k+16\rightarrow12k+8\rightarrow6k+4\]
所以，3步后，$n$和$n+1$到达相同的值，这意味着$n$和$n+1$的算法长度相同。\par
d）略，同上 \par
e）略
%
\exercise 使用code/exe5\_5.py的代码输出表格：
\begin{center}
\tiny
\begin{tabular}{*{8}{l}}
    $T(1)=3$ & $T(2)=3$ & $T(3)=8$ & $T(4)=3$ & $T(5)=6$ & $T(6)=9$ & $T(7)=17$ & $T(8)=4$\\
    $T(9)=20$ & $T(10)=7$ & $T(11)=15$ & $T(12)=10$ & $T(13)=10$ & $T(14)=18$ & $T(15)=18$ & $T(16)=5$\\
    $T(17)=13$ & $T(18)=21$ & $T(19)=21$ & $T(20)=8$ & $T(21)=8$ & $T(22)=16$ & $T(23)=16$ & $T(24)=11$\\
    $T(25)=24$ & $T(26)=11$ & $T(27)=112$ & $T(28)=19$ & $T(29)=19$ & $T(30)=19$ & $T(31)=107$ & $T(32)=6$\\
    $T(33)=27$ & $T(34)=14$ & $T(35)=14$ & $T(36)=22$ & $T(37)=22$ & $T(38)=22$ & $T(39)=35$ & $T(40)=9$\\
    $T(41)=110$ & $T(42)=9$ & $T(43)=30$ & $T(44)=17$ & $T(45)=17$ & $T(46)=17$ & $T(47)=105$ & $T(48)=12$\\
    $T(49)=25$ & $T(50)=25$ & $T(51)=25$ & $T(52)=12$ & $T(53)=12$ & $T(54)=113$ & $T(55)=113$ & $T(56)=20$\\
    $T(57)=33$ & $T(58)=20$ & $T(59)=33$ & $T(60)=20$ & $T(61)=20$ & $T(62)=108$ & $T(63)=108$ & $T(64)=7$\\
    $T(65)=28$ & $T(66)=28$ & $T(67)=28$ & $T(68)=15$ & $T(69)=15$ & $T(70)=15$ & $T(71)=103$ & $T(72)=23$\\
    $T(73)=116$ & $T(74)=23$ & $T(75)=15$ & $T(76)=23$ & $T(77)=23$ & $T(78)=36$ & $T(79)=36$ & $T(80)=10$\\
    $T(81)=23$ & $T(82)=111$ & $T(83)=111$ & $T(84)=10$ & $T(85)=10$ & $T(86)=31$ & $T(87)=31$ & $T(88)=18$\\
    $T(89)=31$ & $T(90)=18$ & $T(91)=93$ & $T(92)=18$ & $T(93)=18$ & $T(94)=106$ & $T(95)=106$ & $T(96)=13$\\
    $T(97)=119$ & $T(98)=26$ & $T(99)=26$ & $T(100)=26$\\
\end{tabular}
\end{center}